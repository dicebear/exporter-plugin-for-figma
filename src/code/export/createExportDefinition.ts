import { DefinitionColors, DefinitionComponents, Export } from '../types';
import { removeEmptyValuesFromObject } from '../utils/removeEmptyValuesFromObject';
import { createTemplateString } from './createTemplateString';
import { sortComponents } from '../utils/sortComponents';
import { sortColors } from '../utils/sortColors';
import { getLicenseAsText } from '../utils/getLicenseAsText';
import { parse } from 'svgson';
import { convertSvgsonToDefinition } from '../utils/convertSvgsonToDefinition';

export async function createExportDefinition(exportData: Export) {

  const size = ((await figma.getNodeByIdAsync(exportData.frame.id)) as FrameNode).width;
  const components: DefinitionComponents = [];
  const colors: DefinitionColors = [];

  // Collect components
  for (const [componentGroupKey, componentGroupValue] of Object.entries(exportData.components)) {
    const rotation = componentGroupValue.settings.rotation;
    const probability = componentGroupValue.settings.probability;

    const offsetX = componentGroupValue.settings.offsetX;
    const offsetY = componentGroupValue.settings.offsetY;

    const index = components.push({
      name: componentGroupKey,
      width: 0,
      height: 0,
      rotation: typeof rotation === 'number' ? (rotation === 0 ? [rotation] : [rotation * -1, rotation]) : undefined,
      probability: typeof probability === 'number' ? probability : undefined,
      offset: {
        x: typeof offsetX === 'number' ? (offsetX === 0 ? [offsetX] : [offsetX * -1, offsetX]) : undefined,
        y: typeof offsetY === 'number' ? (offsetY === 0 ? [offsetY] : [offsetY * -1, offsetY]) : undefined,
      },
      variants: [],
    });

    for (const [componentKey, componentValue] of Object.entries(componentGroupValue.collection)) {
      const componentNode = (await figma.getNodeByIdAsync(componentValue.id)) as ComponentNode;
      const componentContent = await createTemplateString(exportData, componentNode);
      const componentContentWithSvg = `<svg>${componentContent}</svg>`;

      components[index - 1].width = Math.max(components[index - 1].width, componentNode.width);
      components[index - 1].height = Math.max(components[index - 1].height, componentNode.height);

      components[index - 1].variants.push({
        name: componentKey,
        content: convertSvgsonToDefinition(await parse(componentContentWithSvg)).children ?? [],
      });
    }
  }

  // Collect background color
  if (exportData.frame.settings.backgroundColorGroupName) {
    const colorGroup = exportData.colors[exportData.frame.settings.backgroundColorGroupName];

    if (colorGroup) {
      colors.push({
        name: 'background',
        values: Object.values(colorGroup.collection).map((v) => v.value),
      });
    }
  }

  // Collect colors
  for (const [colorGroupKey, colorGroupValue] of Object.entries(exportData.colors)) {
    if (!colorGroupValue.isUsedByComponents) {
      continue;
    }

    const notEqualToCollection = colorGroupValue.settings.notEqualTo;
    const contrastTo = colorGroupValue.settings.contrastTo;

    colors.push({
      name: colorGroupKey,
      notEqualTo: Object.entries(notEqualToCollection)
        .filter(([key, value]) => {
          if (key === 'background' || exportData.colors[key]?.isUsedByComponents) {
            return value;
          }

          return false;
        })
        .map(([key]) => key),
      contrastTo:
        contrastTo === 'background' || (contrastTo && exportData.colors[contrastTo]?.isUsedByComponents)
          ? contrastTo
          : undefined,
      values: Object.values(colorGroupValue.collection).map((v) => v.value),
    });
  }

  // Create definition
  const bodyContent = await createTemplateString(exportData, (await figma.getNodeByIdAsync(exportData.frame.id)) as FrameNode);
  const bodyContentWithSvg = `<svg>${bodyContent}</svg>`;

  return JSON.stringify(
    removeEmptyValuesFromObject({
      $schema: 'https://static.dicebear.com/schema/v1/definition.json#',
      $comment:
        'This file was generated by the DiceBear Exporter for Figma. https://www.figma.com/community/plugin/1005765655729342787',
      meta: {
        license: {
          name: exportData.frame.settings.licenseName.trim(),
          url: exportData.frame.settings.licenseUrl.trim(),
          text: getLicenseAsText(exportData),
        },
        creator: {
          name: exportData.frame.settings.creator.trim(),
          url: exportData.frame.settings.homepage.trim(),
        },
        source: {
          name: exportData.frame.settings.sourceTitle.trim(),
          url: exportData.frame.settings.source.trim(),
        },
      },
      body: {
        content: convertSvgsonToDefinition(await parse(bodyContentWithSvg)).children ?? [],
        width: size,
        height: size,
      },
      attributes: {
        fill: 'none',
        'shape-rendering': exportData.frame.settings.shapeRendering,
      },
      components: sortComponents(components),
      colors: sortColors(colors),
    }),
    undefined,
    2
  );
}

import { DefinitionColors, DefinitionComponents, Export } from '../types';
import { removeEmptyValuesFromObject } from '../utils/removeEmptyValuesFromObject';
import { createTemplateString } from './createTemplateString';
import { getDependencies } from '../utils/getDependencies';
import { sortComponents } from '../utils/sortComponents';
import { sortColors } from '../utils/sortColors';

export async function createExportDefinition(exportData: Export) {
  const size = (figma.getNodeById(exportData.frame.id) as FrameNode).width;
  const components: DefinitionComponents = [];
  const colors: DefinitionColors = [];

  // Collect components
  for (const [componentGroupKey, componentGroupValue] of Object.entries(exportData.components)) {
    const index = components.push({
      name: componentGroupKey,
      rotation: componentGroupValue.settings.rotation || undefined,
      probability: componentGroupValue.settings.probability || undefined,
      offset: {
        x: componentGroupValue.settings.offsetX || undefined,
        y: componentGroupValue.settings.offsetY || undefined,
      },
      values: [],
    });

    for (const [componentKey, componentValue] of Object.entries(componentGroupValue.collection)) {
      const componentNode = figma.getNodeById(componentValue.id) as ComponentNode;
      const componentContent = await createTemplateString(exportData, componentNode);

      components[index - 1].values.push({
        name: componentKey,
        content: componentContent,
        dependencies: getDependencies(componentContent),
        default: componentGroupValue.settings.defaults[componentKey] ?? false,
      });
    }
  }

  // Collect background color
  if (exportData.frame.settings.backgroundColorGroupName) {
    const colorGroup = exportData.colors[exportData.frame.settings.backgroundColorGroupName];

    if (colorGroup) {
      colors.push({
        'name': 'background',
        'values': Object.values(colorGroup.collection).map((v) => v.value),
      });
    }
  }

  // Collect colors
  for (const [colorGroupKey, colorGroupValue] of Object.entries(exportData.colors)) {
    if (!colorGroupValue.isUsedByComponents) {
      continue;
    }

    const differentFromColor = colorGroupValue.settings.differentFromColor;
    const contrastColor = colorGroupValue.settings.contrastColor;

    colors.push({
      name: colorGroupKey,
      differentFromColor:
        differentFromColor === 'background' ||
        (differentFromColor && exportData.colors[differentFromColor]?.isUsedByComponents)
          ? differentFromColor
          : undefined,
      contrastColor:
        contrastColor === 'background' || (contrastColor && exportData.colors[contrastColor]?.isUsedByComponents)
          ? contrastColor
          : undefined,
      values: Object.values(colorGroupValue.collection).map((v) => v.value),
    });
  }

  // Create definition
  const bodyContent = await createTemplateString(exportData, figma.getNodeById(exportData.frame.id) as FrameNode);

  return JSON.stringify(
    removeEmptyValuesFromObject({
      $schema: 'https://www.dicebear.com/schema/definition.json',
      $comment:
        'This file was generated by the DiceBear Exporter for Figma. https://www.figma.com/community/plugin/1005765655729342787',
      meta: {
        license: {
          name: exportData.frame.settings.licenseName,
          url: exportData.frame.settings.licenseUrl,
          content: exportData.frame.settings.licenseContent,
        },
        creator: {
          name: exportData.frame.settings.creator,
          url: exportData.frame.settings.homepage,
        },
        source: {
          name: exportData.frame.settings.sourceTitle,
          url: exportData.frame.settings.source,
        },
        size: {
          width: size,
          height: size,
        },
      },
      body: {
        content: bodyContent,
        dependencies: getDependencies(bodyContent),
      },
      attributes: [
        {
          name: 'fill',
          value: 'none',
        },
        {
          name: 'shape-rendering',
          value: exportData.frame.settings.shapeRendering,
        },
      ],
      components: sortComponents(components),
      colors: sortColors(colors),
    }),
    undefined,
    2
  );
}
